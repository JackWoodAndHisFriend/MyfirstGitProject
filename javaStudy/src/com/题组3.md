### 1.并行和并发有什么区别？
并行是两个或多个事件在同一时刻发生，并发是两个或多个事件在同一时间间隔发生。<br>
并行是在不同实体上的多个事件，并发是同一实体上的多个事件<br>
并发编程的目的是充分利用处理器的每一个核，以达到最高的处理性能。
### 2.线程和进程的区别？
进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高<br>
线程是进程的一个实体，是cpu调度和分派的基本单位，同一进程中的多个线程可以并发执行。
### 3.守护线程是什么？
守护线程是一个服务线程，就是服务其他的线程。
### 4.创建线程有哪几种方式？
1.继承Thread类来创建线程<br>
2.通过Runnable接口创建线程类<br>
3.通过Callable和Future创建线程<br>
### 5.runnable和callable有什么区别？
runnable接口中的run()方法返回值是void，它做的事情只是纯粹的去执行run()方法中的代码而已。<br>
callable接口中的call()方法是有返回值的，是一个泛型.
### 6.线程有哪些状态？
五种，创建，就绪，运行，阻塞和死亡。<br>
创建:生成了线程对象，还没有调用该对象的start()方法时，它处在创建状态。<br>
就绪：调用start()方法后，就是就绪<br>
运行：线程的调度程序把处在就绪状态的线程设置为当前线程，此时线程就进入了运行状态。<br>
阻塞：线程运行的时候被暂停，如sleep,wait，就进入阻塞状态<br>
死亡：run()方法执行结束后或者调用了stop方法后，就死亡<br>
### 7.sleep()和wait()有什么区别？
sleep()是线程类(Thread)的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等休眠时间结束后,线程进入就绪状态和其他线程一起竞争cpu执行时间。<br>
wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能访问，可以通过notify，notifyAll方法来唤醒等待的线程。
### 8.notify()和notifyAll()有什么区别？
notify随机唤醒一个wait线程<br>
notifyAll()唤醒所有wait线程<br>
### 9.线程的run()和start()有什么区别？
用start()来启动线程，真正实现了多线程运行，这时无需等待run方法体中的代码执行完毕而直接执行后续的代码。线程处于就绪状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里的run称为线程体，run运行结束，此线程随即终止。
### 10.创建线程池有哪几种方式？
1.newFixedThreadPool:创建一个固定长度的线程池<br>
每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。<br>
2.newCachedThreadPool:创建一个可缓存的线程池，如果规模超过处理需求就会自动回收空闲线程。<br>
当任务数增加时，又可以智能的添加新线程来处理任务。<br>
此线程池不会对大小做限制，大小完全依赖于jvm能创建的最大线程数量。<br>
3.newSingleThreadExecutor():单线程的Executor<br>
这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。<br>
此线程池保证所有任务的执行顺序按照任务的提交顺序执行。<br>
4.newScheduledThreadPool:创建
一个固定长度的线程池，并且周期性执行任务
### 11.线程池有哪些状态？
running，shutdown，stop，tidying，terminated
### 12.线程池中submit()和execute()方法有什么区别？
接收的参数不一样<br>
submit有返回值，execute没有<br>
submit方便Exception处理
### 13.在java中怎么保证多线程的运行安全？
线程安全体现在三个方面：<br>
原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作。<br>
可见性：一个线程对主内存的修改可以及时被其他线程看到<br>
有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，观察结果一般杂乱无序。
### 14.多线程锁的升级原理是什么？
在java中，锁一共有4种状态，级别从低到高依次是：无状态锁，偏向锁，轻量级锁，重量级锁。这几个状态会随着竞争情况逐渐升级，锁可以升级但不能降级。
### 15.什么是死锁？
死锁是两个或两个以上的进程在执行过程中，由于竞争资源或彼此通讯而造成的一种阻塞现象，若无外力作用，他们都将无法推经下去。<br>
这些永远在相互等待的进程叫做死锁进程。<br>
### 16.怎么防止死锁？
### 17.ThreadLocal是什么？有哪些使用场景？
线程局部变量，是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。<br>
### 18.Synchronized底层实现原理
### 19.synchronized和volatile的区别？
volatile本质是告诉jvm当前变量在寄存器中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有安全线程可以访问该变量，其他线程被阻塞住。<br>
volatile只能使用在变量级别；sychronized可以用在变量，方法，类；<br>
volatile仅能实现变量的修改可见性，不能保证原子性；synchronized可以保证修改可见性和原子性；<br>
volatile不会造成线程的阻塞；synchronized可能会导致阻塞；<br>
volatile标记的变量不会被编译器优化；synchronized的则可以被优化
### 20.synchronized和lock有什么区别？
synchronized是java内置关键字，lock是个java类；<br>
synchronized无法判断是否获取到锁的状态，lock可以判断是否获取到锁；<br>
synchronized会自动释放锁，lock需要在finally中手动释放锁；<br>
### 21.synchronized和ReentrantLock的区别是什么？
synchronized是java内置关键字，ReentrantLock是个java类；<br>
ReentrantLock可以获取各种锁的信息<br>
### 22.atomic的原理？
atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个变量进行操作时，具有排他性，即只有一个线程能操作成功，未成功的线程可以像自旋锁一样，继续尝试，一直等到执行成功。<br>
### 23. jdk线程池？
线程池的作用是限制系统中执行线程的数量，提高线程的复用性。<br>
用线程池控制线程数量，其他线程排队等待。一个任务执行完毕，再从队列中取最前面的认为开始执行。<br>
**为什么要用线程池？**：
1. 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。<br>
2. 可根据需要调整线程池中工作线程的数目<br>




